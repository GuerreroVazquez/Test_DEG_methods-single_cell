---
title: "Batch_correction"
output: html_document
date: "2023-11-29"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
setwd("~/Documents/GitHub/Test_DEG_methods-single_cell/batch_correction")

```

```{r}
library(sva)
library(plyr)
library(DESeq2)
library(tidyverse)
library(pheatmap)
library(RColorBrewer)
```




## Gettin the microarray data

Expression.csv is a file where each column is a sample, each row a gene and in each cell I have the expression level. In this specific case is microarray data.

Samples_age_class.csv contains the metadata of each sample, being the most important the Geo_accesion, Experiment and X

```{r}
expression_path =  "Expression.csv"
samples_data_path = "Samples_age_class.csv"



```


```{r}
counts<- read.csv(expression_path)
exp_design <- read.csv(samples_data_path)

```


Here I convert the counts (expression) to matrix, then get the X (age group) and Experiment from the metadata of the samples.

```{r}

rownames(counts) <- counts[,1]
counts <- counts[,-1]
colnames(counts) <- sub("\\.1$", "", colnames(counts))

```

I found that there were 40 columns that repeat (at the end of the dataframe), so I will just remove them
```{r}
counts <- counts[1:(length(counts)-40)]

```



```{r message=FALSE, warning=FALSE}
cts <- as.matrix(counts)

exp_design$Condition <- factor(exp_design$X)
exp_design$Batch <- factor(exp_design$Experiment)

batches_unique = unique(sort(exp_design$Experiment))
batches = exp_design$Experiment
batch_seq = seq(1, length(batches_unique))
batches <- mapvalues(batches, from = batches_unique, to = batch_seq)

exp_design$batch_num <- batches
batches = exp_design$batch_num
batches <- as.numeric(batches)
```

Now I have my batches defined, I will now get them by condition (X)
```{r}
cl_unique = unique(sort(exp_design$X))
cl = exp_design$X
condition_seq = seq(1, length(cl_unique))
cl = mapvalues(cl, from = cl_unique, to = condition_seq)
```
I need the col names to be the gene names in case of the expression (counts) and the sample (geo_accesion) for the exp_desing.

```{r}
rownames(exp_design) <- exp_design[,4]
# exp_design <- exp_design[,-4]   ; This one is not necesary 

```


Currently I have more samples in the exp_desing than the ones that I evaluate so I need to remove them
```{r}
# Get the subset of exp_design with row names present in counts
result <- subset(exp_design, rownames(exp_design) %in% colnames(counts))
#colnames ( subset(counts, colnames(counts)  %in% rownames(exp_design)) ) 
#rownames ( subset(exp_design, rownames(exp_design) %in% colnames(counts)) )
result
setdiff(rownames(exp_design), rownames(result))
setdiff(colnames(counts), rownames(result))
setdiff(colnames(counts), rownames(exp_design))
```


Now I have both, so I will get...  ComBat_seqs(?) 
*Note: what is that?
```{r}
adjusted <- ComBat_seq(cts, batch=batches, group=NULL)
```



```{r}
# Perform batch correction using ComBat
# Assuming the 'GB_ACC' column is numeric and all other columns are numeric
# You may need to modify the model matrix accordingly based on your data

model_matrix <- model.matrix(~1, data = filtered_dfs[[1]])

combat_result <- sva::ComBat(dat = do.call(rbind, filtered_dfs),
                        batch = factor(rep(1:length(filtered_dfs), sapply(filtered_dfs, nrow))),
                        mod = model_matrix)

# Create a data frame with the corrected values
corrected_df <- data.frame(combat_result)

# Save the corrected data to a new CSV file
write.csv(corrected_df, file = "corrected_data.csv", row.names = FALSE)

# Print a message indicating the process is complete
cat("Batch correction and merging completed. Corrected data saved to 'corrected_data.csv'.\n")
```


```{r}

# Assuming filtered_df is your list of data frames

# 1. Create dataframe "master_df"
genes <- lapply(filtered_df, function(df) unique(row.names(df)))

# 2. Assign genes to only the unique values of genes
unique_genes <- unique(unlist(genes))

# 3. Create master_df as an empty dataframe with the row names as genes
master_df <- data.frame(stringsAsFactors = FALSE, row.names = unique_genes)


# 2. Create an empty list "batches_n"
batches_n <- list()

# 3. For each df in filtered_df
for (df in filtered_df) {
  
  # 3.1 Count how many columns it has and add it to batches_n
  batches_n <- c(batches_n, ncol(df))
  missing_rows <- setdiff(row.names(master_df), row.names(df))

  # Create a dataframe with NAs for the missing rows
  missing_df <- data.frame(GB_ACC = missing_rows, stringsAsFactors = FALSE, row.names = missing_rows)
  missing_df[, names(df)] <- NA
  missing_df <- missing_df[, names(df), drop = FALSE]

  # Bind the missing_df to df
  df_filled <- rbind(df, missing_df)
  # 3.2 Append the df to master_df
  master_df <- cbind(master_df, df_filled)
  #master_df <- merge(master_df, df, by.x = 0, by.y = 0, all = TRUE)

}

# Convert the list of column counts to a data frame
batches_n_df <- data.frame(Batch_Column_Count = unlist(batches_n))

```






```{r}
distinct_counts <- sapply(master_df, function(x) n_distinct(x))


```


```{r}
result_list <- c()
ind= 0
for (i in batches_n_df[[1]]) {
  result_list <- c(result_list, rep(ind, i))
  ind=ind+1
}
result_list
```


```{r}

model_matrix <- model.matrix(~1, data = master_df)
batches <- factor(result_list)
model_matrix <- model.matrix(~ 0 + batches)

  # Apply ComBat
combat_result <- sva::ComBat(dat = master_df,
                          batch = batches,  # Assuming one batch per data frame
                          mod = model_matrix)
```
```{r}
master_df
write.csv(master_df, "master_df")
```





