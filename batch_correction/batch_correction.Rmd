---
title: "Batch_correction"
output: html_document
date: "2023-11-29"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
setwd("~/Documents/GitHub/Test_DEG_methods-single_cell/batch_correction")

```

```{r}
library(sva)
library(plyr)
library(DESeq2)
library(tidyverse)
library(pheatmap)
library(RColorBrewer)
```




## Gettin the microarray data

Expression.csv is a file where each column is a sample, each row a gene and in each cell I have the expression level. In this specific case is microarray data.

Samples_age_class.csv contains the metadata of each sample, being the most important the Geo_accesion, Experiment and X

```{r}
expression_path =  "Expression.csv"
samples_data_path = "Samples_age_class.csv"



```


```{r}
counts<- read.csv(expression_path)
exp_design <- read.csv(samples_data_path)

```


Here I convert the counts (expression) to matrix, then get the X (age group) and Experiment from the metadata of the samples.

```{r}

rownames(counts) <- counts[,1]
counts <- counts[,-1]
colnames(counts) <- sub("\\.1$", "", colnames(counts))

```

I found that there were 40 columns that repeat (at the end of the dataframe), so I will just remove them
```{r}
counts <- counts[1:(length(counts)-40)]

```


I need the col names to be the gene names in case of the expression (counts) and the sample (geo_accesion) for the exp_desing.

```{r}
rownames(exp_design) <- exp_design[,4]
# exp_design <- exp_design[,-4]   ; This one is not necesary 

```


Currently I have more samples in the exp_desing than the ones that I evaluate so I need to remove them
```{r}
# Get the subset of exp_design with row names present in counts
exp_design <- subset(exp_design, rownames(exp_design) %in% colnames(counts))
clean_counts <- counts[, intersect(colnames(counts), rownames(exp_design))]

exp_design$Condition <- factor(exp_design$X)
exp_design$Batch <- factor(exp_design$Experiment)
```



```{r message=FALSE, warning=FALSE}




batches_unique = unique(sort(exp_design$Experiment))
batches = exp_design$Experiment
batch_seq = seq(1, length(batches_unique))
batches <- mapvalues(batches, from = batches_unique, to = batch_seq)

exp_design$batch_num <- batches
batches = exp_design$batch_num
batches <- as.numeric(batches)
```

Now I have my batches defined, I will now get them by condition (X)
```{r}
cl_unique = unique(sort(exp_design$X))
cl = exp_design$X
condition_seq = seq(1, length(cl_unique))
cl = mapvalues(cl, from = cl_unique, to = condition_seq)
```


Now I have both, so I will get...  ComBat_seqs(?) 
*Note: what is that?
```{r}
log_counts <- log2(clean_counts + 1)
cts <- as.matrix(log_counts)
#cts[is.na(cts)] <- 0
#cts[cts < 0] <- 0
adjusted <- ComBat_seq(cts, batch=batches, group=NULL)
```


